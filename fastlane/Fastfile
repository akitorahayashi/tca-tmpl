# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#     https://docs.fastlane.tools/plugins/available-plugins
#
# To see a list of all available lanes, run `bundle exec fastlane lanes`
#

default_platform(:ios)

require "fileutils"
require_relative "config"

before_all do
  ENV["FL_BUILDLOG_PATH"] = LOGS_PATH
  ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "20"

  [
    BUILD_PATH,
    LOGS_PATH,
    TEST_LOGS_PATH,
    BUILD_LOGS_PATH,
    TEST_RESULTS_PATH,
  ].each { |path| FileUtils.mkdir_p(path) }
end

platform :ios do
  # === Build-only Lanes ===
  desc "Build unsigned debug archive"
  lane :build_debug do |options|
    options ||= {}
    build_app_with_config(
      configuration: CONFIGURATIONS[:debug],
      xcargs: options[:xcargs]
    )
  end

  desc "Build unsigned release archive"
  lane :build_release do |options|
    options ||= {}
    build_app_with_config(
      configuration: CONFIGURATIONS[:release],
      xcargs: options[:xcargs]
    )
  end

  # === Signing-only Lanes ===
  desc "Sign debug archive for development"
  lane :sign_debug_development do
    sign_archive(
      archive_path: DEBUG_ARCHIVE_PATH,
      export_method: EXPORT_METHODS[:development],
      configuration: CONFIGURATIONS[:debug]
    )
  end

  desc "Sign release archive with specified export method (development, app_store, ad_hoc, enterprise)"
  lane :sign_release do |options|
    options ||= {}
    sign_archive(
      archive_path: RELEASE_ARCHIVE_PATH,
      export_method: options[:export_method],
      configuration: CONFIGURATIONS[:release]
    )
  end

  # === Test Lanes ===
  desc "Build for testing"
  lane :build_for_testing do |options|
    options ||= {}
    configuration = options[:configuration] || CONFIGURATIONS[:debug]

    scan_args = {
      project: PROJECT_PATH,
      scheme: SCHEMES[:app],
      destination: simulator_destination_from(options),
      derived_data_path: File.join(TEST_DERIVED_DATA_PATH, configuration),
      configuration: configuration,
      build_for_testing: true,
      clean: true,
      buildlog_path: TEST_LOGS_PATH,
      suppress_xcode_output: true,
    }

    passed_xcargs = options[:xcargs].to_s.strip
    scan_args[:xcargs] = passed_xcargs unless passed_xcargs.empty?

    begin
      scan(**scan_args)
      UI.success("✅ Build-for-testing successful (output suppressed)")
    rescue => ex
      UI.error("❌ Build-for-testing failed for scheme '#{SCHEMES[:app]}'")
      print_latest_xcodebuild_log(buildlog_path: scan_args[:buildlog_path], lines: 200)
      raise ex
    end
  end

  desc "Run unit tests"
  lane :unit_test do |options|
    options ||= {}
    test_with_scheme({ scheme: SCHEMES[:unit_test], result_path: UNIT_TEST_RESULT_PATH }.merge(options))
  end

  desc "Run unit tests without building"
  lane :unit_test_without_building do |options|
    options ||= {}
    test_with_scheme(
      {
        scheme: SCHEMES[:unit_test],
        result_path: UNIT_TEST_RESULT_PATH,
        test_without_building: true,
      }.merge(options)
    )
  end

  desc "Run integration tests"
  lane :intg_test do |options|
    options ||= {}
    test_with_scheme({ scheme: SCHEMES[:intg_test], result_path: INTG_TEST_RESULT_PATH }.merge(options))
  end

  desc "Run integration tests without building"
  lane :intg_test_without_building do |options|
    options ||= {}
    test_with_scheme(
      {
        scheme: SCHEMES[:intg_test],
        result_path: INTG_TEST_RESULT_PATH,
        test_without_building: true,
      }.merge(options)
    )
  end

  desc "Run UI tests"
  lane :ui_test do |options|
    options ||= {}
    test_with_scheme({ scheme: SCHEMES[:ui_test], result_path: UI_TEST_RESULT_PATH }.merge(options))
  end

  desc "Run UI tests without building (xcodebuild test-without-building)"
  lane :ui_test_without_building do |options|
    options ||= {}
    test_with_scheme(
      {
        scheme: SCHEMES[:ui_test],
        result_path: UI_TEST_RESULT_PATH,
        test_without_building: true,
      }.merge(options)
    )
  end

  desc "Run all tests (Unit, UI, Intg)"
  lane :test_all do |options|
    options ||= {}
    build_for_testing(options)
    unit_test_without_building(options)
    intg_test_without_building(options)
    ui_test_without_building(options)
  end

  # === Private ===

  def simulator_destination_from(options)
    destination = options[:destination].to_s.strip
    return destination unless destination.empty?

    udid = options[:udid].to_s.strip
    return "platform=iOS Simulator,id=#{udid}" unless udid.empty?

    env_destination = ENV["SIMULATOR_DESTINATION"].to_s.strip
    return env_destination unless env_destination.empty?

    selected_udid = find_available_iphone_simulator_udid
    if selected_udid.empty?
      UI.user_error!("Unable to find an available iPhone simulator on this runner.")
    end

    UI.message("Using simulator UDID: #{selected_udid}")
    "platform=iOS Simulator,id=#{selected_udid}"
  end

  def find_available_iphone_simulator_udid
    output = sh("xcrun simctl list devices available 'iPhone'", log: false)
    output.to_s[/[0-9A-Fa-f-]{36}/].to_s.strip
  rescue StandardError
    ""
  end

  def print_latest_xcodebuild_log(buildlog_path:, lines:)
    log_dir = File.expand_path(buildlog_path.to_s, Dir.pwd)
    log_file = Dir.glob(File.join(log_dir, "**", "*.log")).max_by do |path|
      File.mtime(path)
    rescue StandardError
      Time.at(0)
    end

    if log_file.nil? || !File.file?(log_file)
      UI.error("Could not find xcodebuild logs under: #{log_dir}")
      return
    end

    UI.message("Showing last #{lines} lines from log: #{log_file}")
    UI.message(File.read(log_file).lines.last(lines).join)
  rescue StandardError => error
    UI.error("Failed to read xcodebuild logs under #{log_dir}: #{error}")
  end

  def config_paths(configuration)
    case configuration
    when CONFIGURATIONS[:release]
      {
        archive_path: RELEASE_ARCHIVE_PATH,
        derived_data_path: RELEASE_BUILD_DERIVED_DATA_PATH,
      }
    when CONFIGURATIONS[:debug]
      {
        archive_path: DEBUG_ARCHIVE_PATH,
        derived_data_path: DEBUG_BUILD_DERIVED_DATA_PATH,
      }
    else
      UI.user_error!(
        "Unknown configuration: #{configuration}. Must be one of #{CONFIGURATIONS.values.join(', ')}"
      )
    end
  end

  private_lane :build_app_with_config do |options|
    configuration = options[:configuration]
    paths = config_paths(configuration)

    FileUtils.mkdir_p(File.dirname(paths[:archive_path]))
    FileUtils.mkdir_p(paths[:derived_data_path])
    FileUtils.mkdir_p(BUILD_LOGS_PATH)

    passed_xcargs = options[:xcargs].to_s.strip
    build_app(
      project: PROJECT_PATH,
      scheme: SCHEMES[:app],
      configuration: configuration,
      clean: true,
      skip_codesigning: true,
      skip_package_ipa: true,
      derived_data_path: paths[:derived_data_path],
      archive_path: paths[:archive_path],
      export_team_id: ENV["TEAM_ID"],
      buildlog_path: BUILD_LOGS_PATH,
      suppress_xcode_output: true,
      xcargs: passed_xcargs,
    )
  end

  private_lane :sign_archive do |options|
    export_base = case options[:configuration]
                  when CONFIGURATIONS[:release] then RELEASE_EXPORT_BASE
                  when CONFIGURATIONS[:debug] then DEBUG_EXPORT_BASE
                  else
                    UI.user_error!("Unknown configuration: #{options[:configuration]}")
                  end

    build_app(
      project: PROJECT_PATH,
      scheme: SCHEMES[:app],
      archive_path: options[:archive_path],
      export_method: options[:export_method],
      skip_build_archive: true,
      output_directory: File.join(export_base, options[:export_method].to_s),
      export_team_id: ENV["TEAM_ID"]
    )
  end

  private_lane :test_with_scheme do |options|
    result_path = File.expand_path(options[:result_path], Dir.pwd)
    sh("rm -rf \"#{result_path}\"")

    configuration = options[:configuration] || CONFIGURATIONS[:debug]
    derived_data_path = File.join(TEST_DERIVED_DATA_PATH, configuration)

    FileUtils.mkdir_p(File.dirname(result_path))
    FileUtils.mkdir_p(TEST_LOGS_PATH)
    FileUtils.mkdir_p(derived_data_path)

    scan_args = {
      project: PROJECT_PATH,
      scheme: options[:scheme],
      destination: simulator_destination_from(options),
      derived_data_path: derived_data_path,
      result_bundle_path: result_path,
      code_coverage: false,
      output_types: "xcresult",
      clean: false,
      buildlog_path: TEST_LOGS_PATH,
      suppress_xcode_output: true,
    }

    passed_xcargs = options[:xcargs].to_s.strip
    scan_args[:xcargs] = passed_xcargs unless passed_xcargs.empty?
    scan_args[:test_without_building] = true if options[:test_without_building]

    begin
      scan(**scan_args)
      UI.success("✅ Test successful for scheme '#{options[:scheme]}' (output suppressed)")
    rescue => ex
      UI.error("❌ Test failed for scheme '#{options[:scheme]}'")
      print_latest_xcodebuild_log(buildlog_path: scan_args[:buildlog_path], lines: 100)
      raise ex
    end
  end
end
