# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#     https://docs.fastlane.tools/plugins/available-plugins
#
# To see a list of all available lanes, run `bundle exec fastlane lanes`
#

default_platform(:ios)

require_relative 'config'

before_all do
  # Set the global log path default to the project-local directory
  # This becomes the fallback if buildlog_path is not specified
  ENV["FL_BUILDLOG_PATH"] = LOGS_PATH
end

platform :ios do
# === Build-only Lanes ===
  desc "Build unsigned debug archive"
  lane :build_debug do |options|
    build_app_with_config(
      configuration: CONFIGURATIONS[:debug],
      xcargs: options[:xcargs] || ""
    )
  end

  desc "Build unsigned release archive"
  lane :build_release do |options|
    build_app_with_config(
      configuration: CONFIGURATIONS[:release],
      xcargs: options[:xcargs] || ""
    )
  end

  # === Signing-only Lanes ===
  desc "Sign debug archive for development"
  lane :sign_debug_development do
    sign_archive(
      archive_path: DEBUG_ARCHIVE_PATH,
      export_method: EXPORT_METHODS[:development],
      configuration: CONFIGURATIONS[:debug]
    )
  end

  desc "Sign release archive with specified export method (development, app_store, ad_hoc, enterprise)"
  lane :sign_release do |options|
    export_method = options[:export_method]
    sign_archive(
      archive_path: RELEASE_ARCHIVE_PATH,
      export_method: export_method,
      configuration: CONFIGURATIONS[:release]
    )
  end

  # === Test Lanes ===
  desc "Build for testing"
  lane :build_for_testing do |options|
    configuration = options[:configuration] || CONFIGURATIONS[:debug]
    derived_data_path = "#{TEST_DERIVED_DATA_PATH}/#{configuration}"

    passed_xcargs = options[:xcargs] || ""

    xcargs_items = []
    if configuration == CONFIGURATIONS[:release]
      xcargs_items << "ENABLE_TESTABILITY=YES"
    end
    
    xcargs_items << passed_xcargs unless passed_xcargs.empty?
    xcargs = xcargs_items.join(' ')

    get_simulator_info(options)
    udid = Actions.lane_context[:SIMULATOR_UDID]
    scan_args = {
      project: PROJECT_PATH,
      scheme: SCHEMES[:app],
      destination: "platform=iOS Simulator,id=#{udid}",
      derived_data_path: derived_data_path,
      configuration: configuration,
      build_for_testing: true,
      clean: true,
      buildlog_path: TEST_LOGS_PATH,
      suppress_xcode_output: true
    }
    scan_args[:xcargs] = xcargs unless xcargs.empty?
    scan(**scan_args)
  end

  desc "Run unit tests"
  lane :unit_test do |options|
    test_with_scheme(scheme: SCHEMES[:unit_test], result_path: UNIT_TEST_RESULT_PATH, **options)
  end

  desc "Run unit tests without building"
  lane :unit_test_without_building do |options|
    test_with_scheme(scheme: SCHEMES[:unit_test], result_path: UNIT_TEST_RESULT_PATH, test_without_building: true, **options)
  end

  desc "Run integration tests"
  lane :intg_test do |options|
    test_with_scheme(scheme: SCHEMES[:intg_test], result_path: INTG_TEST_RESULT_PATH, **options)
  end

  desc "Run integration tests without building"
  lane :intg_test_without_building do |options|
    test_with_scheme(scheme: SCHEMES[:intg_test], result_path: INTG_TEST_RESULT_PATH, test_without_building: true, **options)
  end

  desc "Run UI tests"
  lane :ui_test do |options|
    test_with_scheme(scheme: SCHEMES[:ui_test], result_path: UI_TEST_RESULT_PATH, **options)
  end

  desc "Run UI tests without building (xcodebuild test-without-building)"
  lane :ui_test_without_building do |options|
    test_with_scheme(scheme: SCHEMES[:ui_test], result_path: UI_TEST_RESULT_PATH, test_without_building: true, **options)
  end

  desc "Run all tests (Unit, UI, Intg)"
  lane :test_all do
    build_for_testing
    unit_test_without_building
    intg_test_without_building
    ui_test_without_building
  end

# === Private ===

  desc "Get simulator information based on environment"
  private_lane :get_simulator_info do |options|
    udid = options[:udid]
    if udid.nil? || udid.empty?
      if is_ci?
        udid = sh("xcrun simctl list devices available 'iPhone' | grep -Eo '[A-F0-9-]{36}' | head -n 1").strip
        if udid.nil? || udid.empty?
          UI.user_error!("CI環境で利用可能なiPhoneシミュレータのUDIDが取得できませんでした")
        end
      else
        UI.user_error!("UDIDが指定されていません。justfileからudidオプションを渡してください")
      end
    end
    Actions.lane_context[:SIMULATOR_UDID] = udid
  end

  desc "Build with specified configuration"
  def config_paths(configuration)
    case configuration
    when CONFIGURATIONS[:release]
      {
        archive_path: RELEASE_ARCHIVE_PATH,
        derived_data_path: RELEASE_BUILD_DERIVED_DATA_PATH
      }
    when CONFIGURATIONS[:debug]
      {
        archive_path: DEBUG_ARCHIVE_PATH,
        derived_data_path: DEBUG_BUILD_DERIVED_DATA_PATH
      }
    else
      UI.user_error!("Unknown configuration: #{configuration}. Must be one of #{CONFIGURATIONS.values.join(', ')}")
    end
  end

  private_lane :build_app_with_config do |options|
    configuration = options[:configuration]
    passed_xcargs = options[:xcargs] || ""
    paths = config_paths(configuration)
    build_app(
      project: PROJECT_PATH,
      scheme: SCHEMES[:app],
      configuration: configuration,
      clean: true,
      skip_codesigning: true,
      skip_package_ipa: true,
      derived_data_path: paths[:derived_data_path],
      archive_path: paths[:archive_path],
      export_team_id: ENV['TEAM_ID'],
      buildlog_path: BUILD_LOGS_PATH,
      suppress_xcode_output: true,
      xcargs: passed_xcargs
    )
  end

  desc "Sign and export archive with specified export method"
  private_lane :sign_archive do |options|
    export_method = options[:export_method]
    archive_path = options[:archive_path]
    configuration = options[:configuration]
    
    export_base = case configuration
                  when CONFIGURATIONS[:release] then RELEASE_EXPORT_BASE
                  when CONFIGURATIONS[:debug] then DEBUG_EXPORT_BASE
                  else UI.user_error!("Unknown configuration: #{configuration}")
                  end

    build_app(
      project: PROJECT_PATH,
      scheme: SCHEMES[:app],
      archive_path: archive_path,
      export_method: export_method,
      skip_build_archive: true,
      output_directory: "#{export_base}/#{export_method}",
      export_team_id: ENV['TEAM_ID']
    )
  end

  desc "Run test for a given scheme (optionally without building)"
  private_lane :test_with_scheme do |options|
    result_path = File.expand_path(options[:result_path], Dir.pwd)
    sh("rm -rf \"#{result_path}\"")
    get_simulator_info(options)
    udid = Actions.lane_context[:SIMULATOR_UDID]
    
    configuration = options[:configuration] || CONFIGURATIONS[:debug]
    derived_data_path = "#{TEST_DERIVED_DATA_PATH}/#{configuration}"
    
    passed_xcargs = options[:xcargs] || ""

    scan_args = {
      project: PROJECT_PATH,
      scheme: options[:scheme],
      destination: "platform=iOS Simulator,id=#{udid}",
      derived_data_path: derived_data_path,
      result_bundle_path: result_path,
      code_coverage: false,
      output_types: "xcresult",
      clean: false,
      buildlog_path: TEST_LOGS_PATH,
      suppress_xcode_output: true
    }

    scan_args[:xcargs] = passed_xcargs unless passed_xcargs.empty?
    scan_args[:test_without_building] = options[:test_without_building] if options[:test_without_building]

    begin
      scan_args[:fail_build] = false
      scan(**scan_args)
      UI.success("✅ Test successful for scheme '#{options[:scheme]}' (output suppressed)")
    rescue => ex
      log_path = lane_context[SharedValues::SCAN_BUILDLOG_PATH]
      UI.error("❌ Test failed. Showing last 100 lines from log: #{log_path}")
      
      if log_path && File.exist?(log_path)
        UI.message(File.read(log_path).lines.last(100).join)
      else
        UI.error("Could not find log file at: #{log_path}")
      end
      raise ex
    end
  end
end